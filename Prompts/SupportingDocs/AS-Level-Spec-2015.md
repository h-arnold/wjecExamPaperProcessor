## **1. Computer Architecture, Data, Communication and Applications**

### **1.1 Hardware and communication**

#### **1.1.1 Architecture**

- **1.1.1.1** Identify and describe the main components of contemporary computer architecture, including Von Neumann architectures.
- **1.1.1.2** Describe different types of memory and caching.
- **1.1.1.3** Describe and explain parallel processing.

#### **1.1.2 Fetch-execute cycle**

- **1.1.2.1** Describe the fetch-execute cycle showing how data can be read from RAM into registers.

#### **1.1.3 Input / Output**

- **1.1.3.1** Describe the use of contemporary methods and their associated devices for input and output.
- **1.1.3.2** Explain the use of these methods and devices in contemporary computer systems and their suitability in different situations.

#### **1.1.4 Secondary storage**

- **1.1.4.1** Compare the functional characteristics of contemporary secondary storage devices.

#### **1.1.5 Data storage on disc**

- **1.1.5.1** Explain fragmentation and its consequences and describe the need for defragmentation.

#### **1.1.6 Networking**

- **1.1.6.1** Describe networks and how they communicate.
- **1.1.6.2** Explain the importance of networking standards.
- **1.1.6.3** Describe the importance and the use of a range of contemporary protocols including HTTP, FTP, SMTP, TCP/IP, IMAP, DHCP, UDP and wireless communication protocols.
- **1.1.6.4** Explain the role of handshaking.

#### **1.1.7 Internet**

- **1.1.7.1** Describe the internet in terms of a world-wide communications infrastructure.

### **1.2 Logical operations**

- **1.2.1** Draw truth tables for Boolean expressions consisting of AND, OR, NOT and XOR logical operations.
- **1.2.2** Apply logical operations to combinations of conditions in programming, including clearing registers and masking.
- **1.2.3** Simplify Boolean expressions using Boolean identities and rules.

### **1.3 Data transmission**

#### **1.3.1 Methods of transmission**

- **1.3.1.1** Describe serial and parallel transmission, their advantages and disadvantages.
- **1.3.1.2** Describe simplex, half duplex and full duplex transmission methods.
- **1.3.1.3** Explain the need for multiplexing and switching.

#### **1.3.2 Communication networks**

- **1.3.2.1** Describe, using appropriate network protocols such as TCP/IP, the typical contents of a packet.
- **1.3.2.2** Explain network collision, network collision detection and how these collisions are dealt with.
- **1.3.2.3** Describe methods of routing traffic on a network.

### **1.4 Data representation and data types**

#### **1.4.1 Representation of data as bit patterns**

- **1.4.1.1** Explain the terms bit, byte and word.
- **1.4.1.2** Describe and use the binary number system and hexadecimal notation as shorthand for binary number patterns.

#### **1.4.2 Storage of characters**

- **1.4.2.1** Describe how characters and numbers are stored in binary form.
- **1.4.2.2** Describe standardised character sets.

#### **1.4.3 Data types**

- **1.4.3.1** Describe the following different primitive data types: Boolean, character, string, integer and real.
- **1.4.3.2** Describe the storage requirements for each data type.

#### **1.4.4 Representation of numbers as bit patterns**

- **1.4.4.1** Apply binary arithmetic techniques.
- **1.4.4.2** Explain the representation of positive and negative integers in a fixed-length store using both twoâ€™s complement, and sign and magnitude representation.
- **1.4.4.3** Describe the nature and uses of floating point form.
- **1.4.4.4** State the advantages and disadvantages of representing numbers in integer and floating point forms.
- **1.4.4.5** Convert between real number and floating point form.
- **1.4.4.6** Describe truncation and rounding, and explain their effect upon accuracy.

### **1.5 Data structures**

- **1.5.1** Describe, interpret and manipulate data structures including arrays (up to two dimensions) and records.
- **1.5.2** Describe the manipulation of records and arrays.
- **1.5.3** Select, identify and justify appropriate data structures for given situations.

### **1.6 Organisation of data**

#### **1.6.1 File organisation and access**

- **1.6.1.1** Explain the purpose of files in data processing.
- **1.6.1.2** Define a file in terms of records and fields.
- **1.6.1.3** Explain fixed and variable length fields and records and give examples of the appropriate use of each type.
- **1.6.1.4** Design files and records appropriate for a particular application.
- **1.6.1.5** Distinguish between master and transaction files.
- **1.6.1.6** Describe sequential, indexed sequential and direct (random) file access.
- **1.6.1.7** Distinguish between the use of serial and sequential file access methods in computer applications.
- **1.6.1.8** Describe and design algorithms and programs for sequential file access and update.
- **1.6.1.9** Explain the need for file security, including file backup, generations of files and transaction logs.
- **1.6.1.10** Describe the need for archiving files.

#### **1.6.2 Data validation and verification**

- **1.6.2.1** Explain and apply appropriate techniques for data validation and verification.
- **1.6.2.2** Design algorithms and programming routines that validate and verify data.

### **1.7 Database systems**

- **1.7.1** Describe and discuss the benefits and drawbacks of relational database systems and other contemporary database systems.
- **1.7.2** Describe the use of primary and foreign keys, indexes and links.
- **1.7.3** Explain and apply entity relationship modelling and use it to analyse simple problems.
- **1.7.4** Describe the advantages of different users having different views of the data in a database.

### **1.8 The operating system**

#### **1.8.1 Managing resources**

- **1.8.1.1** Describe the need for and the role of the operating system kernel in managing resources, including peripherals, processes, memory protection and backing store.

#### **1.8.2 Providing an interface**

- **1.8.2.1** Describe the need for and the role of the operating system in providing an interface between the user and the hardware.

#### **1.8.3 Managing backing store**

- **1.8.3.1** Explain the hierarchical structure of a directory and describe file attributes.

#### **1.8.4 Utility software**

- **1.8.4.1** Explain the need for and use of a range of utility software.

#### **1.8.5 Modes of operation**

- **1.8.5.1** Describe the main features of batch processing, real time control and real time transaction systems.
- **1.8.5.2** Identify and describe applications that would be suitable to these modes of operation.

#### **1.8.6 Consideration of human-computer interaction**

- **1.8.6.1** Explain the need to design systems that are appropriate to the variety of different users at all levels and in different environments.

### **1.9 Algorithms and programs**

#### **1.9.1 Algorithm definition and analysis**

- **1.9.1.1** Explain the term algorithm and describe common methods of defining algorithms, including pseudo-code, flowcharts and structured English.

#### **1.9.2 Variables and constants**

- **1.9.2.1** Identify and explain the use of constants and variables in algorithms and programs.

#### **1.9.3 Identifiers**

- **1.9.3.1** Describe why the use of self-documenting identifiers, annotation and program layout are important in programs. Give examples of self-documenting identifiers, annotation and appropriate program layout.

#### **1.9.4 Scope of variables**

- **1.9.4.1** Describe the scope and lifetime of variables in algorithms and programs.

#### **1.9.5 Parameters**

- **1.9.5.1** Explain the purpose and effect of procedure calling, parameter passing and return, call by reference and call by value.

#### **1.9.6 Mathematical operations**

- **1.9.6.1** Identify, explain and use mathematical operations in algorithms, including DIV and MOD.

#### **1.9.7 Sorting algorithms**

- **1.9.7.1** Describe the characteristics of sorting algorithms: bubble sort and insertion sort.

#### **1.9.8 Searching algorithms**

- **1.9.8.1** Explain and apply a linear search algorithm.
- **1.9.8.2** Explain and apply the binary search algorithm.
- **1.9.8.3** Describe appropriate circumstances for the use of each searching technique.
- **1.9.8.4** Follow search and sort algorithms and programs and make alterations to such algorithms.
- **1.9.8.5** Write search algorithms and programs.

#### **1.9.9 Problem analysis**

- **1.9.9.1** Analyse a problem using appropriate design approaches.

#### **1.9.10 Programming constructs**

- **1.9.10.1** Identify, explain and use sequence, selection and repetition in algorithms and programs.
- **1.9.10.2** Identify, explain and use counts and rogue values in algorithms and programs.
- **1.9.10.3** Follow algorithms and programs involving sequence, selection and repetition and make alterations to such algorithms.
- **1.9.10.4** Write algorithms and programs involving sequence, selection and repetition to solve non-standard problems.

#### **1.9.11 Modular programming**

- **1.9.11.1** Identify and explain the nature, use and possible benefits of standard functions, standard modules and user-defined subprograms.

#### **1.9.12 Logical operations in algorithms and programs**

- **1.9.12.1** Identify, use and explain the logical operators AND, OR, NOT and XOR in algorithms and programs.

#### **1.9.13 Compression**

- **1.9.13.1** Explain data compression and how data compression algorithms are used.

#### **1.9.14 Testing**

- **1.9.14.1** Select appropriate test data to dry-run a program or algorithm in order to identify possible errors.
- **1.9.14.2** Explain the purpose of a given algorithm by showing the effects of test data.

### **1.10 Principles of programming**

#### **1.10.1 Programming paradigms**

- **1.10.1.1** Describe the distinguishing features of different types of programming paradigms, including procedural, event-driven, visual and mark-up languages.
- **1.10.1.2** Describe the role of an object-oriented approach to programming and the relationship between object, class and method.

#### **1.10.2 Levels of computer language**

- **1.10.2.1** Describe the differences between high-level and low-level languages.
- **1.10.2.2** Identify and describe situations that require the use of a high-level or a low-level language.

#### **1.10.3 Types of computer language**

- **1.10.3.1** Identify and justify which type of language would be best suited to develop a solution to a given problem.

### **1.11 Systems analysis**

#### **1.11.1 Feasibility**

- **1.11.1.1** Describe the purpose of a feasibility study and describe the processes that an analyst would carry out during a feasibility study.
- **1.11.1.2** Explain that proposed solutions must be cost-effective, developed to an agreed timescale and within an agreed budget.

#### **1.11.2 Investigation and analysis**

- **1.11.2.1** Describe the different methods of investigation including direct observation, questionnaires, study of existing documentation and interview.
- **1.11.2.2** Analyse a problem using appropriate techniques of abstraction and decomposition.

#### **1.11.3 Design**

- **1.11.3.1** Represent and interpret systems in an appropriate diagrammatic form showing the flow of data and the information processing requirements.
- **1.11.3.2** Describe the selection of suitable software and hardware to address the requirements of a problem.

#### **1.11.4 Changeover**

- **1.11.4.1** Describe the various methods of changeover: direct, pilot, phased and parallel, identify the most suitable in a given situation and their relative merits.

#### **1.11.5 Program testing**

- **1.11.5.1** Describe the use of alpha, beta and acceptance testing.

#### **1.11.6 Maintenance**

- **1.11.6.1** Describe the nature and use made of perfective, adaptive and corrective maintenance.

#### **1.11.7 Backup and recovery**

- **1.11.7.1** Describe different procedures for backing up and recovering data.

#### **1.11.8 Documentation**

- **1.11.8.1** Describe the contents and use made of user documentation and maintenance documentation, including annotated listings, variable lists, algorithms and data dictionaries.

### **1.12 Software engineering**

#### **1.12.1 Software tools**

- **1.12.1.1** Explain the role of Integrated Development Environment (IDE) tools in developing and debugging programs.

### **1.13 Program construction**

#### **1.13.1 Compilers, interpreters and assemblers**

- **1.13.1.1** Describe the principal stages involved in the compilation process: lexical analysis, symbol table construction, syntax analysis, semantic analysis, code generation and optimisation.

### **1.14 The need for different types of software systems and their attributes**

#### **1.14.1 Types of software**

- **1.14.1.1** Explain the use of a range of types of software, including open source software, bespoke and off-the-shelf.

#### **1.14.2 Industrial, technical and scientific**

- **1.14.2.1** Describe the role of the computer in weather forecasting, computer aided design, robotics and the use of computer-generated graphics and animation.

#### **1.14.3 Expert systems**

- **1.14.3.1** Explain the purpose, use and significance of expert systems.

### **1.15 Practical programming**

- **1.15.1** Design programs, including data structures and programming routines, to solve given problems.
- **1.15.2** Develop programs from documented designs, producing annotated listings.
- **1.15.3** Evaluate programs, identifying successful features and suggesting specific improvements.

### **1.16 Data security and integrity processes**

- **1.16.1** Describe privacy, security, disaster planning, and malicious or accidental damage to data and appropriate responses.

### **1.17 Economic, moral, legal, ethical and cultural issues relating to computer science**

- **1.17.1** Describe social and economic changes due to developments in computing and their consequences.
- **1.17.2** Describe the effects of computers on employment.
- **1.17.3** Explain how relevant legislation impacts security, privacy, data protection and freedom of information.