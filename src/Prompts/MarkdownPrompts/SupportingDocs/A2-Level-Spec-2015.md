# WJEC A2-Level Computer Science Specification - 2015

## **3. Programming and System Development**

### **3.1 Data Structures**

- **3.1.1** Describe, interpret and manipulate data structures including arrays (up to three dimensions), stacks, queues, trees, linked lists and hash tables.  
- **3.1.2** Describe the manipulation of arrays (up to three dimensions).  
- **3.1.3** Represent the operation of stacks and queues using pointers and arrays.  
- **3.1.4** Represent the operation of linked lists and trees using pointers and arrays.  

---

### **3.2 Logical Operations**

- **3.2.1** Draw truth tables for Boolean expressions, including NAND and NOR logical operations.  
- **3.2.2** Apply logical operations to combinations of conditions in programming, including clearing registers, masking and encryption.  
- **3.2.3** Simplify Boolean expressions using Boolean identities, rules and De Morgan’s laws.  

---

### **3.3 Algorithms and Programs**

- **3.3.1** Explain the term algorithm and describe common methods of defining algorithms, including pseudo-code and flowcharts.  

#### **3.3.2 Recursion**

- **3.3.2.1** Explain the use of recursion in algorithms and programs and consider the potential elegance of this approach.  

#### **3.3.3 Validation and Verification**

- **3.3.3.1** Identify, explain and apply appropriate techniques of validation and verification in algorithms and programs.  

#### **3.3.4 Sorting**

- **3.3.4.1** Explain the need for a variety of sorting algorithms both recursive and non-recursive.  
- **3.3.4.2** Describe the characteristics of sorting algorithms, including quicksort.  
- **3.3.4.3** Explain the effect of storage space required, number of comparisons of data items, number of exchanges needed and number of passes through the data on the efficiency of a sorting algorithm.  
- **3.3.4.4** Use Big O notation to determine the efficiency of different sorting algorithms in terms of their time and space requirements and to compare the efficiency of different sorting algorithms.  

#### **3.3.5 Searching**

- **3.3.5.1** Explain and apply a shortest-path algorithm.  
- **3.3.5.2** Use Big O notation to determine the efficiency of linear and binary searches in terms of execution time and space requirements and to compare the efficiency of different searching algorithms.  
- **3.3.5.3** Follow search and sort algorithms and programs and make alterations to such algorithms.  
- **3.3.5.4** Write search and sort algorithms and programs.  

#### **3.3.6 Logical Operations in Algorithms and Programs**

- **3.3.6.1** Identify, use and explain logical operators in algorithms and programs, including NAND and NOR.  

#### **3.3.7 Traversal of Data Structures**

- **3.3.7.1** Write and interpret algorithms used in the traversal of data structures.  

#### **3.3.8 Compression**

- **3.3.8.1** Explain data compression and how data compression algorithms are used.  
- **3.3.8.2** Compare and explain the efficiency of data compression algorithms in terms of compression ratio, compression time, decompression time and saving percentage.  

#### **3.3.9 Testing**

- **3.3.9.1** Select appropriate test data.  
- **3.3.9.2** Dry-run a program or algorithm in order to identify possible errors, including logical errors.  
- **3.3.9.3** Explain the purpose of a given algorithm by showing the effects of test data.  

#### **3.3.10 Comparing Algorithms**

- **3.3.10.1** Use Big O notation to determine the complexity and efficiency of given algorithms in terms of their execution time, their memory requirements and between algorithms that perform the same task.  

---

### **3.4 Principles of Programming**

- **3.4.1** Explain the nature and relative advantages of different programming paradigms, and identify possible situations where they may be used.  
- **3.4.2** Describe the role of an object-oriented approach to programming and the relationship between object, class and method.  
- **3.4.3** Describe the need for the standardisation of computer languages, and the potential difficulties involved in agreeing and implementing standards.  
- **3.4.4** Identify ambiguities in natural language and explain the need for computer languages to have an unambiguous syntax.  
- **3.4.5** Interpret and use formal methods of expressing language syntax: syntax diagrams and Backus-Naur form (extended Backus-Naur form is not to be used).  

---

### **3.5 Systems Analysis**

#### **3.5.1 Approaches**

- **3.5.1.1** Describe different appropriate approaches to analysis and design, including Waterfall and Agile.  

#### **3.5.2 Documentation**

- **3.5.2.1** Explain at which stage of the development which pieces of documentation would be produced.  

---

### **3.6 System Design**

#### **3.6.1 Human-Computer Interaction**

- **3.6.1.1** Discuss contemporary approaches to the problem of communication with computers.  
- **3.6.1.2** Describe the potential for a natural language interface.  
- **3.6.1.3** Describe the problems of ambiguity that can be associated with input that is spoken.  

#### **3.6.2 Design Validation**

- **3.6.2.1** Explain the need for a design review to:  
  - Check the correspondence between a design and its specification  
  - Confirm that the most appropriate techniques have been used  
  - Confirm that the user interface is appropriate  

#### **3.6.3 Design Evaluation**

- **3.6.3.1** Describe criteria for the evaluation of computer-based solutions.  

---

### **3.7 Software Engineering**

- **3.7.1** Describe the types of software tool that have been designed to assist the software engineering process.  
- **3.7.2** Explain the role of appropriate software packages in systems analysis, systems specification, systems design and testing.  
- **3.7.3** Explain program version management.  

---

### **3.8 Program Construction**

#### **3.8.1 Compilers, Interpreters and Assemblers**

- **3.8.1.1** Describe the function of translation programs in making source programs executable by the computer.  
- **3.8.1.2** Describe the purpose and give examples of the use of compilers, interpreters and assemblers, and distinguish between them.  
- **3.8.1.3** Distinguish between and give examples of translation and execution errors.  

---

### **3.9 Economic, Moral, Legal, Ethical and Cultural Issues**

#### **3.9.1 Professional Behaviour**

- **3.9.1.1** Describe the role of codes of conduct in promoting professional behaviour.  

## **4. Computer Architecture, Data, Communication and Applications**

### **4.1 Hardware and Communication**

#### **4.1.1 Architecture**

- **4.1.1.1** Identify and describe the main components of contemporary computer architecture.  
- **4.1.1.2** Describe and explain the limiting factors to parallelisation in parallel processing.  
- **4.1.1.3** Calculate the runtime of given tasks as a result of parallelisation and evaluate the effect of parallelisation.  

#### **4.1.2 Assembly Language Programming**

- **4.1.2.1** Write simple programs in assembly language and demonstrate how these programs could be executed.  

#### **4.1.3 Input / Output**

- **4.1.3.1** Describe and differentiate between:
  - Voice input for command and control systems
  - Vocabulary dictation systems for general input
  - Voice print recognition for security  
- **4.1.3.2** Discuss the suitability of each voice system in different situations.  

#### **4.1.4 Networking**

- **4.1.4.1** Identify and describe applications where connecting a portable device to a network is required.  
- **4.1.4.2** Describe the hardware required to make a wireless connection and explain how this might be achieved using contemporary wireless technologies.  

---

### **4.2 Data Transmission**

#### **4.2.1 Communication Networks**

- **4.2.1.1** Calculate data transfer rates on a network.  
- **4.2.1.2** Calculate lowest cost routes on a network.  
- **4.2.1.3** Describe the internet in terms of a worldwide communications infrastructure.  

---

### **4.3 Data Representation and Data Types**

#### **4.3.1 Representation of Numbers as Bit Patterns** ★

- **4.3.1.1** Apply binary arithmetic techniques.  
- **4.3.1.2** Explain the representation of positive and negative integers in a fixed-length store using both two’s complement and sign and magnitude representation.  
- **4.3.1.3** Describe the nature and uses of floating point form.  
- **4.3.1.4** State the advantages and disadvantages of representing numbers in integer and floating point forms.  
- **4.3.1.5** Convert between real number and floating point form.  
- **4.3.1.6** Describe truncation and rounding, and explain their effect upon accuracy.  

#### **4.3.2 Bitwise Operations**

- **4.3.2.1** Explain and use shift functions: logical and arithmetic shifts.  
- **4.3.2.2** Interpret and apply shifts in algorithms and programs.  
- **4.3.2.3** Describe the causes of overflow and underflow.  

---

### **4.4 Organisation and Structure of Data**

#### **4.4.1 File Design and Organisation**

- **4.4.1.1** Describe how files may be created, organised, updated and processed by programs.  
- **4.4.1.2** Explain the purpose of, and be able to use, a hashing algorithm.  
- **4.4.1.3** Compare different hashing algorithms.  
- **4.4.1.4** Explain the use of multi-level indexes.  
- **4.4.1.5** Explain the techniques used to manage overflow and the need for file re-organisation.  

---

### **4.5 Databases and Distributed Systems**

#### **4.5.1 Database Concepts**

- **4.5.1.1** Explain what is meant by data consistency, data redundancy and data independence.  
- **4.5.1.2** Explain what is meant by relational database organisation and data normalisation (first, second and third normal forms).  
- **4.5.1.3** Restructure data into third normal form.  
- **4.5.1.4** Explain and apply entity relationship modelling and use it to analyse problems.  
- **4.5.1.5** Explain how the data can be manipulated to provide the user with useful information.  

#### **4.5.2 Data Validation and Verification**

- **4.5.2.1** Explain and apply appropriate techniques for data validation and verification of data in databases.  

#### **4.5.3 Searching Data**

- **4.5.3.1** Explain the purpose of query languages.  
- **4.5.3.2** Construct and run queries using Structured Query Language (SQL).  

#### **4.5.4 Database Management Systems**

- **4.5.4.1** Explain the purpose of a database management system (DBMS) and data dictionaries.  

#### **4.5.5 Big Data and Distributed Systems**

- **4.5.5.1** Explain what is meant by Big Data, predictive analytics, data warehousing and data mining.  
- **4.5.5.2** Explain that distribution can apply to both data and processing.  
- **4.5.5.3** Describe distributed databases and the advantages of such distribution.  

---

### **4.6 The Operating System**

#### **4.6.1 Types of Operating System**

- **4.6.1.1** Explain the following types of system:
  - Batch  
  - Single-user (standalone)  
  - Multi-user (multi-access)  
  - Multi-tasking  
  - Multi-programming  

#### **4.6.2 Interrupts**

- **4.6.2.1** Describe a range of conditions or events which could generate interrupts.  
- **4.6.2.2** Describe interrupt handling and the use of priorities.  
- **4.6.2.3** Describe the factors involved in allocating differing priorities.  

#### **4.6.3 Memory Management and Buffering**

- **4.6.3.1** Explain the reasons for, and possible consequences of, partitioning of main memory.  
- **4.6.3.2** Describe methods of data transfer including the use of buffers to allow for differences in speed of devices.  
- **4.6.3.3** Describe buffering and explain why double buffering is used.  

#### **4.6.4 Scheduling and Process Management**

- **4.6.4.1** Describe the principles of high-level scheduling:
  - Processor allocation  
  - Allocation of devices  
  - Significance of job priorities  
- **4.6.4.2** Explain the three basic states of a process: running, ready and blocked.  
- **4.6.4.3** Explain the role of time-slicing, polling and threading.  

---

### **4.7 The Need for Different Types of Software Systems and Their Attributes**

#### **4.7.1 Types of Software**

- **4.7.1.1** Explain the use of a range of types of software including safety-related, control, expert, wide and local area information exchange systems.  

#### **4.7.2 Safety-Related Systems**

- **4.7.2.1** Explain that some computer applications are safety-related and require a high level of dependability, and hence that the development of safety-critical systems is a highly specialised field.  

#### **4.7.3 Control Systems**

- **4.7.3.1** State the nature and scope of computer control and automation.  
- **4.7.3.2** Describe the benefits and implications of automation.  

#### **4.7.4 Expert Systems**

- **4.7.4.1** Discuss the possible effects of expert systems on professional groups and the wider community.  

#### **4.7.5 Internet and Intranet**

- **4.7.5.1** Describe the use of search engines on the internet.  
- **4.7.5.2** Describe common contemporary applications.  
- **4.7.5.3** Discuss the possible effects of the internet upon professional groups and the wider community.  

---

### **4.8 Data Security and Integrity Processes**

#### **4.8.1 Protecting Data Integrity**

- **4.8.1.1** Explain the special security and integrity problems which can arise during online updating of files.  

#### **4.8.2 Cryptography**

- **4.8.2.1** Describe the need for and the purpose of cryptography.  
- **4.8.2.2** Describe techniques of cryptography and their role in protecting data.  
- **4.8.2.3** Follow algorithms and programs used in cryptography.  
- **4.8.2.4** Compare cryptographic methods and their relative strength.  

#### **4.8.3 Biometrics**

- **4.8.3.1** Describe the purpose and use of contemporary biometric technologies.  
- **4.8.3.2** Describe the benefits and drawbacks of biometric technologies.  
- **4.8.3.3** Describe the complexities of capturing, storing and processing biometric data.  

#### **4.8.4 Malicious Software and Mechanisms of Attack and Defence**

- **4.8.4.1** Describe types and mechanisms of malicious software and their vectors.  
- **4.8.4.2** Describe black hat hacking, white hat hacking and penetration testing.  
