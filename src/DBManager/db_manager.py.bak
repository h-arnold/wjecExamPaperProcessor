"""
Database manager for WJEC Exam Paper Processor.

This module provides functionality to interact with MongoDB for storing
and retrieving exam metadata and related information.
"""

import os
import logging
from datetime import datetime, UTC
from typing import Dict, Any, List, Optional, Union

try:
    import pymongo
    from pymongo import MongoClient
    from pymongo.errors import ConnectionFailure, DuplicateKeyError
    MONGODB_AVAILABLE = True
except ImportError:
    MONGODB_AVAILABLE = False

class DBManager:
    """
    Manages MongoDB database connections and operations for exam metadata.
    
    This class provides methods for connecting to MongoDB, storing exam metadata,
    retrieving documents, and managing relationships between documents.
    """
    
    def __init__(self, connection_string: Optional[str] = None, database_name: str = "wjec_exams"):
        """
        Initialize the database manager.
        
        Args:
            connection_string: MongoDB connection string. If None, uses environment variable
                              MONGODB_URI or falls back to localhost.
            database_name: Name of the MongoDB database to use.
        """
        self.logger = logging.getLogger(__name__)
        
        if not MONGODB_AVAILABLE:
            self.logger.warning("pymongo not installed. MongoDB functionality will not be available.")
            self.client = None
            self.db = None
            return
            
        # Get connection string from parameters or environment
        self.connection_string = connection_string or os.environ.get(
            "MONGODB_URI", "mongodb://localhost:27017/"
        )
        self.database_name = database_name
        self.client = None
        self.db = None
        
        # Try to connect immediately
        try:
            self.connect()
        except ConnectionFailure as e:
            self.logger.error(f"Failed to connect to MongoDB: {e}")
    
    def connect(self) -> None:
        """
        Establish connection to MongoDB.
        
        Raises:
            ConnectionFailure: If connection to MongoDB fails.
        """
        if not MONGODB_AVAILABLE:
            self.logger.error("Cannot connect: pymongo not installed")
            return
            
        try:
            self.client = MongoClient(self.connection_string)
            # Ping the server to verify connection
            self.client.admin.command('ping')
            self.db = self.client[self.database_name]
            self.logger.info(f"Connected to MongoDB: {self.database_name}")
        except ConnectionFailure as e:
            self.logger.error(f"Server not available: {e}")
            raise
    
    def disconnect(self) -> None:
        """
        Close MongoDB connection.
        
        This is an alias for close_connection() for naming consistency.
        """
        self.close_connection()
    
    def close_connection(self) -> None:
        """
        Close MongoDB connection.
        """
        if self.client:
            self.client.close()
            self.client = None
            self.db = None
            self.logger.info("Disconnected from MongoDB")
    
    def get_database(self):
        """
        Return the database instance.
        
        Returns:
            pymongo.database.Database: The MongoDB database instance, or None if not connected.
        """
        return self.db
    
    def document_exists(self, document_id: str) -> bool:
        """
        Check if a document with the given ID exists in the database.
        
        Args:
            document_id: The ID of the document to check.
            
        Returns:
            bool: True if the document exists, False otherwise.
        """
        if not self.db:
            self.logger.error("Not connected to MongoDB")
            return False
            
        try:
            count = self.db.exam_metadata.count_documents({"_id": document_id})
            return count > 0
        except Exception as e:
            self.logger.error(f"Error checking if document exists: {e}")
            return False
    
    def save_exam_metadata(self, metadata: Dict[str, Any], document_id: Optional[str] = None) -> Optional[str]:
        """
        Store exam metadata in MongoDB.
        
        Args:
            metadata: Dictionary containing the metadata to store.
            document_id: Optional ID for the document. If None, will use metadata['document_id']
                        or generate a new ID.
                        
        Returns:
            str: The ID of the stored document, or None if storage failed.
            
        Raises:
            ValueError: If required fields are missing from the metadata.
        """
        if not self.db:
            self.logger.error("Not connected to MongoDB")
            return None
            
        # Ensure required fields are present
        required_fields = ['subject', 'qualification', 'year', 'season', 'unit']
        missing_fields = [field for field in required_fields if field not in metadata]
        
        if missing_fields:
            raise ValueError(f"Missing required metadata fields: {', '.join(missing_fields)}")
        
        # Prepare document for storage
        document = self._prepare_metadata_for_db(metadata, document_id)
        
        try:
            result = self.db.exam_metadata.update_one(
                {"_id": document["_id"]},
                {"$set": document},
                upsert=True
            )
            self.logger.info(f"{'Updated' if result.modified_count else 'Inserted'} document: {document['_id']}")
            return document["_id"]
        except Exception as e:
            self.logger.error(f"Error saving metadata: {e}")
            return None
    
    def get_exam_metadata(self, document_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve a specific document by ID.
        
        Args:
            document_id: The ID of the document to retrieve.
            
        Returns:
            Dict: The retrieved document, or None if not found.
        """
        if not self.db:
            self.logger.error("Not connected to MongoDB")
            return None
            
        try:
            document = self.db.exam_metadata.find_one({"_id": document_id})
            if document:
                return document
            self.logger.warning(f"Document not found: {document_id}")
            return None
        except Exception as e:
            self.logger.error(f"Error retrieving document: {e}")
            return None
    
    def delete_exam_metadata(self, document_id: str) -> bool:
        """
        Remove a document from MongoDB.
        
        Args:
            document_id: The ID of the document to delete.
            
        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        if not self.db:
            self.logger.error("Not connected to MongoDB")
            return False
            
        try:
            result = self.db.exam_metadata.delete_one({"_id": document_id})
            if result.deleted_count > 0:
                self.logger.info(f"Deleted document: {document_id}")
                return True
            self.logger.warning(f"Document not found for deletion: {document_id}")
            return False
        except Exception as e:
            self.logger.error(f"Error deleting document: {e}")
            return False
    
    def bulk_save_exam_metadata(self, metadata_list: List[Dict[str, Any]]) -> List[str]:
        """
        Store multiple metadata records efficiently.
        
        Args:
            metadata_list: List of metadata dictionaries to store.
            
        Returns:
            List[str]: List of document IDs that were successfully stored.
        """
        if not self.db:
            self.logger.error("Not connected to MongoDB")
            return []
            
        if not metadata_list:
            return []
            
        successful_ids = []
        operations = []
        
        for metadata in metadata_list:
            try:
                # Validate required fields
                required_fields = ['subject', 'qualification', 'year', 'season', 'unit']
                missing_fields = [field for field in required_fields if field not in metadata]
                
                if missing_fields:
                    self.logger.warning(
                        f"Skipping document with missing fields: {', '.join(missing_fields)}"
                    )
                    continue
                
                # Prepare document
                document = self._prepare_metadata_for_db(metadata)
                doc_id = document["_id"]
                
                # Create upsert operation
                operations.append(
                    pymongo.UpdateOne(
                        {"_id": doc_id},
                        {"$set": document},
                        upsert=True
                    )
                )
                successful_ids.append(doc_id)
                
            except Exception as e:
                self.logger.error(f"Error preparing document for bulk save: {e}")
        
        # Execute bulk operation if we have any operations
        if operations:
            try:
                result = self.db.exam_metadata.bulk_write(operations)
                self.logger.info(
                    f"Bulk operation: {result.upserted_count} inserted, "
                    f"{result.modified_count} modified"
                )
            except Exception as e:
                self.logger.error(f"Error executing bulk operation: {e}")
                return []
                
        return successful_ids
    
    def _prepare_metadata_for_db(self, metadata: Dict[str, Any], document_id: Optional[str] = None) -> Dict[str, Any]:
        """
        Prepare metadata dictionary for database storage.
        
        Args:
            metadata: The metadata dictionary to prepare.
            document_id: Optional document ID to use.
            
        Returns:
            Dict: Database-ready document.
        """
        # Create a copy to avoid modifying the original
        document = metadata.copy()
        
        # Set document ID
        if document_id:
            document["_id"] = document_id
        elif "document_id" in document:
            document["_id"] = document.pop("document_id")
        else:
            # Generate an ID based on metadata properties
            parts = [
                str(document.get("subject", "unknown")),
                str(document.get("qualification", "unknown")),
                str(document.get("unit", "00")),
                str(document.get("year", "0000")),
                str(document.get("season", "unknown"))
            ]
            document["_id"] = "-".join(parts).lower().replace(" ", "_")
        
        # Add timestamps
        now = datetime.now(UTC)
        if "created_at" not in document:
            document["created_at"] = now
        document["updated_at"] = now
        
        return document